<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>trillium</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="who.html"><strong aria-hidden="true">1.1.</strong> Who is behind this</a></li><li class="chapter-item expanded "><a href="conventions.html"><strong aria-hidden="true">1.2.</strong> About this document</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architectural Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/core_concepts.html"><strong aria-hidden="true">2.1.</strong> Core Concepts</a></li><li class="chapter-item expanded "><a href="overview/handlers.html"><strong aria-hidden="true">2.2.</strong> Handlers</a></li><li class="chapter-item expanded "><a href="overview/conn.html"><strong aria-hidden="true">2.3.</strong> Conn</a></li><li class="chapter-item expanded "><a href="overview/runtimes.html"><strong aria-hidden="true">2.4.</strong> Runtime Adapters and TLS</a></li></ol></li><li class="chapter-item expanded "><a href="handlers.html"><strong aria-hidden="true">3.</strong> A tour of handler libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="handlers/router.html"><strong aria-hidden="true">3.1.</strong> Router</a></li><li class="chapter-item expanded "><a href="handlers/templates.html"><strong aria-hidden="true">3.2.</strong> Template Engines</a></li><li class="chapter-item expanded "><a href="handlers/logger.html"><strong aria-hidden="true">3.3.</strong> Logger</a></li><li class="chapter-item expanded "><a href="handlers/cookies.html"><strong aria-hidden="true">3.4.</strong> Cookies</a></li><li class="chapter-item expanded "><a href="handlers/sessions.html"><strong aria-hidden="true">3.5.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="handlers/proxy.html"><strong aria-hidden="true">3.6.</strong> Proxy</a></li><li class="chapter-item expanded "><a href="handlers/static.html"><strong aria-hidden="true">3.7.</strong> Static Files</a></li><li class="chapter-item expanded "><a href="handlers/websockets.html"><strong aria-hidden="true">3.8.</strong> Websockets</a></li></ol></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">4.</strong> Testing trillium applications</a></li><li class="chapter-item expanded "><a href="library_patterns.html"><strong aria-hidden="true">5.</strong> Patterns for library authors</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">6.</strong> Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">trillium</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/trillium-rs/trillium" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Hi! Welcome to the documentation for Trillium, a modular toolkit for
building async rust web applications.</p>
<p>Trillium runs on stable rust, is fully async, and can run on tokio,
async-std, or smol. Using Trillium starts with code as simple as this:</p>
<pre><code class="language-rust noplaypen">fn main() {
    trillium_smol::run(|conn: trillium::Conn| async move {
        conn.ok(&quot;hello from trillium!&quot;)
    });
}</code></pre>
<p>Trillium is also built to scale up to complex applications
with a full middleware stack comparable to Rails or
Phoenix. Currently, opt-in features include a router, cookies,
sessions, websockets, serving static files from disk or memory, a
reverse proxy, and integrations for three template engine
options. Trillium is just getting started, though, and there's a lot
more to build.</p>
<p>Perhaps most importantly, Trillium intends to be a production-quality
open source http framework for async rust, with support options available
for commercial users.</p>
<p>Trillium's code is at
<a href="https://github.com/trillium-rs/trillium">github</a> and rustdocs are
available at <a href="https://docs.trillium.rs">docs.trillium.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="who-is-behind-this"><a class="header" href="#who-is-behind-this">Who is behind this?</a></h1>
<p>👋 I'm <a href="https://github.com/jbr">jbr</a>. I've been working on tide,
async-h1, and http-types for the last year, and have landed a number
of exciting features in that framework such as sessions, unix socket
listeners, tls, and websockets. I've also done a bunch of work in
tide's http implementation, async-h1. Trillium is the direct product
of that experience. I am continuing to contribute to http-rs, but as
tide's design stabilizes, I am branching out in order to explore a
number of alternative designs that I have been considering for the
majority of the last year.</p>
<p>As such, some of the documentation will reference tide. I also have
substantial experience with node/express, koa, phoenix, sinatra, and
rails, and will try to incorporate references to those frameworks
where appropriate to provide touchstones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-this-document"><a class="header" href="#about-this-document">About this document</a></h1>
<p>Here are some conventions in this document.</p>
<ul>
<li><code>use</code> declarations will only be listed once on the first usage of a
given type in order to keep code samples concise</li>
<li>In-line code looks like this: <code>|conn: Conn| async move { conn }</code> and
will generally not involve fully qualified paths</li>
<li>Footnotes are represented like this<sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>Informational asides look like this:
<blockquote>
<p>ℹ️ Fun fact: Facts are fun</p>
</blockquote>
</li>
<li>Advanced asides look like this
<blockquote>
<p>🧑‍🎓 The handler trait provides several other lifecycle hooks for
library authors</p>
</blockquote>
</li>
<li>Comparisons with Tide
<blockquote>
<p>🌊 Tide endpoints look like <code>|_req: Request&lt;_&gt;| async { Response::new(200) }</code> whereas Trillium handlers look like <code>|conn: Conn| async move { conn.with_status(200) }</code></p>
</blockquote>
</li>
<li>Comparisons with Plug:
<blockquote>
<p>🔌 Halting a plug looks like <code>conn |&gt; halt</code> (elixir), and the
equivalent in trillium is returning <code>conn.halt()</code></p>
</blockquote>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Footnotes can always be skipped</p>
</div>
<h2 id="who-is-this-document-for"><a class="header" href="#who-is-this-document-for">Who is this document for?</a></h2>
<p>This document expects some familiarity with async rust. We intend to
offer a beginner level document at some point, but for now we
recommend looking at <a href="https://doc.rust-lang.org/book/">the rust book</a>
and <a href="https://rust-lang.github.io/async-book/">the async book</a>.</p>
<p>We also assume familiarity with web development in general, including
concepts and patterns in http servers and frameworks.</p>
<p>In particular, we offer comparisons to rust's
<a href="https://github.com/http-rs/tide">tide</a> and elixir's
<a href="https://www.phoenixframework.org/">phoenix</a> /
<a href="https://hexdocs.pm/plug/readme.html">plug</a>, as they serve as the
primary inspirations for trillium.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architectural-overview"><a class="header" href="#architectural-overview">Architectural Overview</a></h1>
<h2 id="composition-and-substitution"><a class="header" href="#composition-and-substitution">Composition and Substitution</a></h2>
<p>Trillium is published as a set of components that can be easily composed
to create web servers. One of the goals of this design is that to the
extent possible, all components be replaceable by alternatives.</p>
<h2 id="why-is-substitution-so-important"><a class="header" href="#why-is-substitution-so-important">Why is substitution so important?</a></h2>
<p>Async rust web frameworks still have a lot of exciting exploration
left in the near future. Instead of offering one solution as the best,
trillium offers a playground in which you can experiment with
alternatives. I want it to be painless to plug in an alternative
router, or a different http logger, or anything else you can imagine.</p>
<p>There are a lot of different purposes a web framework might be used
for, and the core library should not have to adapt in order for
someone to add support for each of those features.</p>
<p>Although I imagine that for each of the core components there will
only be one or two options, I think it is an essential aspect of good
software design that frameworks be modular and composable, as there
will always be tradeoffs for any given design.</p>
<h2 id="only-compile-what-you-need"><a class="header" href="#only-compile-what-you-need">Only compile what you need</a></h2>
<p>Instead of your application depending on a library with a large list
of reexported dependencies and conditionally including/excluding them
based on cargo features, trillium tries to apply rust's &quot;only pay for
what you need&quot; approach both at runtime and compile time.  In
particular, trillium avoids pulling in runtimes like tokio or
async-std except in the crates where you explicitly need those,
preferring instead to depend on small crates like <code>futures_lite</code>
wherever possible. Additionally, and in specific contrast to tide,
there is minimal default behavior. If you don't need a router, you
don't need to compile or run a router.</p>
<p>Everything is opt-in, instead of opt-out. Trillium uses small crates,
each of which declares its own dependencies.</p>
<h3 id="relation-to-tide-http-types-and-async-h1"><a class="header" href="#relation-to-tide-http-types-and-async-h1">Relation to tide, http-types, and async-h1</a></h3>
<p>As of trillium-v0.2.0, trillium no longer depends on http-types.</p>
<p>Trillium shares the same session store backends as tide.</p>
<h3 id="relation-to-elixir-plug-and-phoenix"><a class="header" href="#relation-to-elixir-plug-and-phoenix">Relation to Elixir Plug and Phoenix</a></h3>
<p>The general architecture is directly inspired by Plug, and is intended
to be a hybrid of the best of plug and the best of tide. Eventually, I
intend to build an opinionated framework like Phoenix on top of the
components that are Trillium, but I don't expect that to happen for a
bit. I hope to keep the core feature set of trillium quite small and
focus on getting the design right and improving performance as much as
possible. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts-handlers-conn-and-adapters"><a class="header" href="#core-concepts-handlers-conn-and-adapters">Core concepts: Handlers, Conn, and Adapters</a></h1>
<p>The most important concepts when building a trillium application are
the <code>Conn</code> type and the <code>Handler</code> trait. Each <code>Conn</code> represents a
single http request/response pair, and a <code>Handler</code> is the trait that
all applications, middleware, and endpoints implement.</p>
<p>Let's start with an overview of a simple trillium application and then
dig into each of those concepts a little more.</p>
<pre><code class="language-rust noplaypen">fn main() {
    trillium_smol::run(|conn: trillium::Conn| async move {
        conn.ok(&quot;hello from trillium!&quot;)
    });
}</code></pre>
<p>In this example, <code>trillium_smol::run</code> is the runtime adapter and the
closure is a Handler that responds &quot;hello from trillium!&quot; to any web
request it receives. This is a fully functional example that you can
run with only the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
trillium = &quot;0.2&quot;
trillium-smol = &quot;0.2&quot;
</code></pre>
<p>If we <code>cargo run</code> this example, we can then visit
http://localhost:8080 in a browser or make a curl request against that
url and see &quot;hello from trillium!&quot; as the response body. Note that we
won't see any output in the terminal because trillium is silent by
default.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handlers"><a class="header" href="#handlers">Handlers</a></h1>
<p>The simplest form of a handler is any async function that takes a
<code>Conn</code> and returns that <code>Conn</code>. This example sets a <code>200 Ok</code> status
and sets a string body.</p>
<pre><code class="language-rust noplaypen">use trillium::Conn;
async fn hello_world(conn: Conn) -&gt; Conn {
    conn.ok(&quot;hello world!&quot;)
}</code></pre>
<p>With no further modification, we can drop this handler into a trillium
server and it will respond to http requests for us. We're using the
<a href="https://github.com/smol-rs/smol"><code>smol</code></a>-runtime based server adapter
here.</p>
<pre><code class="language-rust noplaypen">pub fn main() {
    trillium_smol::run(hello_world);
}</code></pre>
<p>We can also define this as a closure:</p>
<pre><code class="language-rust noplaypen">pub fn main() {
    trillium_smol::run(|conn: trillium::Conn| async move {
        conn.ok(&quot;hello world&quot;)
    });
}</code></pre>
<p>This handler will respond to any request regardless of path, and it
will always send a <code>200 Ok</code> http status with the specified body of
<code>&quot;hello world&quot;</code>.</p>
<h2 id="the-state-handler"><a class="header" href="#the-state-handler">The State Handler</a></h2>
<p>Trillium offers only one handler in the main <code>trillium</code> crate: The
State handler, which places a clone of any type you provide into the
state set of each conn that passes through it. See the
<a href="https://docs.trillium.rs/trillium/struct.state">rustdocs for State</a>
for example usage.</p>
<h2 id="tuple-handlers"><a class="header" href="#tuple-handlers">Tuple Handlers</a></h2>
<p>Earlier, we discussed that we can use state to send data between
handlers and that handlers can always pass along the conn
unchanged. In order to use this, we need to introduce the notion of
tuple handlers.</p>
<p>Each handler in a tuple handler is called from left to right until the
conn is halted.</p>
<blockquote>
<p>🔌 Readers familiar with elixir plug will recognize this notion as
identical to pipelines, and that the term halt <a href="https://hexdocs.pm/plug/Plug.Conn.html#halt/1">is <del>stolen from</del>
inspired by plug</a></p>
</blockquote>
<pre><code class="language-rust noplaypen">env_logger::init();
use trillium_logger::Logger;
run((
    Logger::new(),
    |conn: Conn| async move { conn.ok(&quot;tuple!&quot;) }
));</code></pre>
<p>This snippet adds a http logger to our application, so that if we
execute our application with <code>RUST_LOG=info cargo run</code> and make a
request to http://localhost:8000, we'll see log output on stdout.</p>
<blockquote>
<p>🧑‍🎓❓ Why not vectors or arrays? Rust vectors and arrays are type
homogeneous, so in order to store the Logger and closure type in the
above example in an array or vector, we'd need to allocate them to
the heap and actually store a smart pointer in our homogeneous
collection. Trillium initially was built around a notion of
&quot;sequences,&quot; which were a wrapper around <code>Vec&lt;Box&lt;dyn Handler + 'static&gt;&gt;</code>. Because tuples are generic over each of their elements,
they can contain heterogeneous elements of different sizes, without
heap allocation or smart pointers.</p>
</blockquote>
<h2 id="implementing-handler"><a class="header" href="#implementing-handler">Implementing Handler</a></h2>
<p>The <a href="https://docs.trillium.rs/trillium/trait.handler">rustdocs for
Handler</a> contains the
full details of the Handler interface for library authors. For many
applications, it will not be necessary to use anything other than an
async function or closure, but Handler can contain its own state and be
implemented for any type that you author.</p>
<h2 id="assorted-implementations-provided-by-the-trillium-crate"><a class="header" href="#assorted-implementations-provided-by-the-trillium-crate">Assorted implementations provided by the trillium crate</a></h2>
<p>You may see a few other types used in tests and examples.</p>
<ul>
<li><code>()</code>: the noop handler, identical to <code>|conn: Conn| async move { conn }</code></li>
<li><code>&amp;'static str</code> and <code>String</code>: This simple handler responds to all
conns by halting, setting a 200-ok status, and sending the string
content as response body. <code>trillium_smol::run(&quot;hello&quot;)</code> is identical
to <code>trillium_smol::run(|conn: Conn| async move { conn.ok(&quot;hello&quot;) })</code></li>
<li><code>Option&lt;impl Handler&gt;</code>: This handler will noop if the option variant
is none. This is useful for conditionally including handlers at
runtime based on configuration or environment.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conn"><a class="header" href="#conn">Conn</a></h1>
<p>Before we explore the concept of a handler further, let's take a look
at <code>Conn</code>. As mentioned above, <code>Conn</code> represents both the request and
response, as well as any data your application associates with that
request-response cycle.</p>
<blockquote>
<p>🧑‍🎓 Advanced aside: Although the naming of Conn is directly
borrowed from Elixir's <a href="https://github.com/elixir-plug/plug"><code>plug</code></a>
and therefore also <a href="https://www.phoenixframework.org/"><code>Phoenix</code></a>,
it does in fact also own (in the rust sense) the singular
<code>TcpStream</code> that represents the connection with the http client, and
dropping a <code>Conn</code> will also disconnect the client as a result.</p>
</blockquote>
<p>The <a href="https://docs.trillium.rs/trillium/struct.conn">rustdocs for Conn</a>
contain the full details for all of the things you can do with a conn.</p>
<h2 id="returning-conn"><a class="header" href="#returning-conn">Returning Conn</a></h2>
<p>In general, because you'll be returning <code>Conn</code> from handlers, it
supports a chainable (fluent) interface for setting properties, like:</p>
<pre><code class="language-rust noplaypen">conn.with_status(202)
    .with_header(&quot;content-type&quot;, &quot;application/something-custom&quot;)
    .with_body(&quot;this is my custom body&quot;)</code></pre>
<h2 id="accessing-http-request-properties"><a class="header" href="#accessing-http-request-properties">Accessing http request properties</a></h2>
<p>Conn also contains read-only properties like request headers, request
path, and request method, each of which have getter associated
functions.</p>
<h2 id="default-response"><a class="header" href="#default-response">Default Response</a></h2>
<p>The default response for a Conn is a 404 with no response body, so it
is always valid to return the Conn from a handler unmodified (<code>|conn: Conn| async move { conn }</code> is the simplest valid handler).</p>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>In addition to holding the request properties and accumulating the
response your application is going to send, a Conn also serves as a
data structure for any information your application needs to associate
with that request. This is especially valuable for communicating
between handlers, and most core handlers are implemented using conn
state. One important caveat to is that each Conn can only contain
exactly one of each type, so it is highly recommended that you only
store types that you define in state.</p>
<blockquote>
<p>🌊 Comparison with Tide: Tide has three different types of state:
Server state, request state, and response state. In Trillium, server
state is achieved using the
<a href="https://docs.trillium.rs/trillium/struct.state"><code>trillium::State</code></a>
handler, which holds any type that is Clone and puts a clone of it
into the state of each Conn that passes through the handler.</p>
</blockquote>
<h2 id="extending-conn"><a class="header" href="#extending-conn">Extending Conn</a></h2>
<p>It is a very common pattern in trillium for libraries to extend Conn
in order to provide additional functionality<sup class="footnote-reference"><a href="#1">1</a></sup>. The Conn interface
does not provide support for sessions, cookies, route params, or many
other building blocks that other frameworks build into the core
types. Instead, to use sessions as an example, <code>trillium_sessions</code>
provides a <code>SessionConnExt</code> trait which provides associated functions
for Conn that offer session support. In general, handlers that put
data into conn state also will provide convenience functions for
accessing that state, and will export a <code>[Something]ConnExt</code> trait.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> 🧑‍🎓 see <a href="overview/../library_patterns.html">library_patterns</a> for an example
of authoring one of these</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-adapters-and-tls"><a class="header" href="#runtime-adapters-and-tls">Runtime Adapters and TLS</a></h1>
<h2 id="runtime-adapters"><a class="header" href="#runtime-adapters">Runtime Adapters</a></h2>
<p>Let's talk a little more about that <code>trillium_smol::run</code> line we've
been writing. Trillium itself is built on <code>futures</code> (<code>futures-lite</code>,
specifically). In order to run it, it needs an adapter to an async
runtime. There there are four of these
currently:</p>
<ul>
<li><a href="https://docs.trillium.rs/trillium_smol"><code>trillium_smol</code></a></li>
<li><a href="https://docs.trillium.rs/trillium_async_std"><code>trillium_async_std</code></a></li>
<li><a href="https://docs.trillium.rs/trillium_tokio"><code>trillium_tokio</code></a></li>
<li><a href="https://docs.trillium.rs/trillium_aws_lambda"><code>trillium_aws_lambda</code></a></li>
</ul>
<p>Although we've been using the smol adapter in these docs thus far, you
should use whichever runtime you prefer. If you expect to have a
dependency on async-std or tokio anyway, you might as well use the
adapter for that runtime. If you're new to async rust or don't have an
opinion, I recommend starting with trillium_smol. It is easy to switch
trillium between runtimes at any point.</p>
<h1 id="12-factor-by-default-but-overridable"><a class="header" href="#12-factor-by-default-but-overridable">12-Factor by default, but overridable</a></h1>
<p>Trillium seeks to abide by a <a href="https://12factor.net/config">12 factor</a> approach to configuration, accepting configuration from the environment wherever possible. The number of configuration points that can be customized through environment variables will likely increase over time.</p>
<p>To run trillium on a different host or port, either provide a <code>HOST</code>
and/or <code>PORT</code> environment variables, or compile the specific values
into the application as follows:</p>
<pre><code class="language-rust noplaypen">pub fn main() {
    trillium_smol::config()
        .with_port(1337)
        .with_host(&quot;127.0.0.1&quot;)
        .run(|conn: trillium::Conn| async move { conn.ok(&quot;hello world&quot;) })
}</code></pre>
<p>In addition to accepting the <code>HOST</code> and <code>PORT</code> configuration from the environment, on cfg(unix) systems, trillium will also pick up a <code>LISTEN_FD</code> environment variable for use with <a href="https://crates.io/crates/catflap">catflap</a>/<a href="https://github.com/mitsuhiko/systemfd">systemfd</a>. On <code>cfg(unix)</code> systems, if the <code>HOST</code> begins with <code>.</code>, <code>/</code>, or <code>~</code>, it is interpreted as a path and bound as a unix domain socket.</p>
<p>For more documentation on the default values and what configuration can be chained onto config(), see <a href="https://docs.trillium.rs/trillium_server_common/struct.config">trillium_server_common::Config</a>.</p>
<h3 id=""><a class="header" href="#"></a></h3>
<h2 id="tls--https"><a class="header" href="#tls--https">TLS / HTTPS</a></h2>
<p>With the exception of aws lambda, which provides its own tls
termination at the load balancer, each of the above servers can be
combined with either rustls or native-tls.</p>
<h3 id="rustls"><a class="header" href="#rustls">Rustls:</a></h3>
<p><a href="https://docs.trillium.rs/trillium_rustls/index.html">rustdocs (main)</a></p>
<pre><code class="language-rust noplaypen">use trillium::Conn;
use trillium_rustls::RustlsAcceptor;

const KEY: &amp;[u8] = include_bytes!(&quot;./key.pem&quot;);
const CERT: &amp;[u8] = include_bytes!(&quot;./cert.pem&quot;);

pub fn main() {
    env_logger::init();
    trillium_smol::config()
        .with_acceptor(RustlsAcceptor::from_single_cert(CERT, KEY))
        .run(|conn: Conn| async move { conn.ok(&quot;ok&quot;) });
}</code></pre>
<h3 id="native-tls"><a class="header" href="#native-tls">Native tls:</a></h3>
<p><a href="https://docs.trillium.rs/trillium_native_tls/index.html">rustdocs (main)</a></p>
<pre><code class="language-rust noplaypen">use trillium::Conn;
use trillium_native_tls::NativeTlsAcceptor;

pub fn main() {
    env_logger::init();
    let acceptor = NativeTlsAcceptor::from_pkcs12(include_bytes!(&quot;./identity.p12&quot;), &quot;changeit&quot;);
    trillium_smol::config()
        .with_acceptor(acceptor)
        .run(|conn: Conn| async move { conn.ok(&quot;ok&quot;) });
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-tour-of-some-of-the-handlers-that-exist-today"><a class="header" href="#a-tour-of-some-of-the-handlers-that-exist-today">A tour of some of the handlers that exist today</a></h1>
<p>In order for trillium to be a usable web framework, we offer a number
of core utilities. However, it is my hope that alternative
implementations for at least some of these will exist in order to
explore the design space and accommodate different design constraints
and tradeoffs. Because not every application will need this
functionality, they are each released as distinct crates from the core
of trillium.</p>
<ul>
<li><a href="./handlers/logger.html">Logger</a></li>
<li><a href="./handlers/cookies.html">Cookies</a></li>
<li><a href="./handlers/sessions.html">Sessions</a></li>
<li><a href="./handlers/templates.html">Template Engines</a></li>
<li><a href="./handlers/proxy.html">Proxy</a></li>
<li><a href="./handlers/static.html">Static File Serving</a></li>
<li><a href="./handlers/websockets.html">Websockets</a></li>
<li><a href="./handlers/router.html">Router</a></li>
<li>http client
<ul>
<li><a href="https://docs.trillium.rs/trillium_client/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/client/examples/client.rs">example</a></li>
</ul>
</li>
<li>reverse proxy
<ul>
<li>use trillium as a reverse proxy for another server</li>
<li><a href="https://docs.trillium.rs/trillium_proxy/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/proxy/examples/proxy.rs">example</a></li>
</ul>
</li>
<li>method override
<ul>
<li>the trillium-method-override crate adds support for using post
requests with a query param as a substitute for other http methods</li>
<li><a href="https://docs.trillium.rs/trillium_method_override/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/method-override/examples/method-override.rs">example</a></li>
</ul>
</li>
<li>head
<ul>
<li>the trillium-head crate supports responding to head requests</li>
<li><a href="https://docs.trillium.rs/trillium_head/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/head/examples/head.rs">example</a></li>
</ul>
</li>
<li>forwarding
<ul>
<li>the trillium-forwarding crate supports setting remote ip and
protocol from forwarded/x-forwarded-* headers sent by trusted
reverse proxies</li>
<li><a href="https://docs.trillium.rs/trillium_forwarding/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/forwarding/examples/forwarding.rs">example</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="router"><a class="header" href="#router">Router</a></h1>
<p><a href="https://docs.trillium.rs/trillium_router/index.html">rustdocs (main)</a></p>
<p>The trillium router is based on
<a href="https://github.com/jbr/routefinder">routefinder</a>. This router
supports two types of patterns: Untyped params and a single
wildcard. Named params are captured in a map-like interface. Any
handler can be mounted inside of a Router (including other Routers),
allowing entire applications to be mounted on a path, and allowing for
tuple handlers to be run on a given route. Any handler mounted inside
of a route that includes a <code>*</code> will have the url rewritten to the
contents of that star.</p>
<p>Alternative routers that are not based on routefinder are a prime
opportunity for innovation and exploration.</p>
<p>Here's a simple example of an application that responds to a request
like http://localhost:8000/greet/earth with &quot;hello earth&quot; and
http://localhost:8000/greet/mars with &quot;hello mars&quot; and responds to
http://localhost:8000 with &quot;hello everyone&quot;</p>
<pre><code class="language-rust noplaypen">use trillium::Conn;
use trillium_router::{Router, RouterConnExt};

pub fn main() {
    trillium_smol::run(
        Router::new()
            .get(&quot;/&quot;, |conn: Conn| async move { conn.ok(&quot;hello everyone&quot;) })
            .get(&quot;/hello/:planet&quot;, |conn: Conn| async move {
                let planet = conn.param(&quot;planet&quot;).unwrap();
                let response_body = format!(&quot;hello {planet}&quot;);
                conn.ok(response_body)
            }),
    );
}</code></pre>
<h2 id="nesting"><a class="header" href="#nesting">Nesting</a></h2>
<p>Trillium also supports nesting routers, making it possible to express
complex sub-applications, vaguely along the lines of a <a href="https://guides.rubyonrails.org/engines.html">rails
engine</a>. When there are
additional types of routers, it will be possible for an application
built with one type of router to be published as a crate and nested
inside of another router as long as they depend on a compatible
version of the <code>trillium</code> crate.</p>
<pre><code class="language-rust noplaypen">use trillium::{conn_try, conn_unwrap, Conn, Handler};
use trillium_logger::Logger;
use trillium_router::{Router, RouterConnExt};

struct User {
    id: usize,
}

mod nested_app {
    use super::*;
    async fn load_user(conn: Conn) -&gt; Conn {
        let id = conn_try!(conn.param(&quot;user_id&quot;).unwrap().parse(), conn);
        let user = User { id }; // imagine we were loading a user from a database here
        conn.with_state(user)
    }

    async fn greeting(mut conn: Conn) -&gt; Conn {
        let user = conn_unwrap!(conn.take_state::&lt;User&gt;(), conn);
        conn.ok(format!(&quot;hello user {}&quot;, user.id))
    }

    async fn post(mut conn: Conn) -&gt; Conn {
        let user = conn_unwrap!(conn.take_state::&lt;User&gt;(), conn);
        let body = conn_try!(conn.request_body_string().await, conn);
        conn.ok(format!(&quot;hello user {}, {}&quot;, user.id, body))
    }

    async fn some_other_route(conn: Conn) -&gt; Conn {
        conn.ok(&quot;this is an uninspired example&quot;)
    }

    pub fn handler() -&gt; impl Handler {
        (
            load_user,
            Router::new()
                .get(&quot;/greeting&quot;, greeting)
                .get(&quot;/some/other/route&quot;, some_other_route)
                .post(&quot;/post&quot;, post),
        )
    }
}
pub fn main() {
    env_logger::init();
    trillium_smol::run((
        Logger::new(),
        Router::new()
            .get(&quot;/&quot;, |conn: Conn| async move { conn.ok(&quot;hello everyone&quot;) })
            .any(&amp;[&quot;get&quot;, &quot;post&quot;], &quot;/users/:user_id/*&quot;, nested_app::handler()),
    ));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="template-engines"><a class="header" href="#template-engines">Template engines</a></h2>
<p>There are currently three template engines for trillium. Although they are in no way mutually exclusive, most applications will want at most one of these.</p>
<h3 id="askama"><a class="header" href="#askama">Askama</a></h3>
<p>Askama is a jinja-based template engine that preprocesses templates at
compile time, resulting in efficient and type-safe templates that are
compiled into the application binary. Here's how it looks:</p>
<p>Given the following file in <code>(cargo root)/templates/examples/hello.html</code>,</p>
<pre><code class="language-django">Hello, {{ name }}!
</code></pre>
<pre><code class="language-rust noplaypen">use trillium::Conn;
use trillium_askama::{AskamaConnExt, Template};

#[derive(Template)]
#[template(path = &quot;examples/hello.html&quot;)]
struct HelloTemplate&lt;'a&gt; {
    name: &amp;'a str,
}

fn main() {
    trillium_smol::run(|conn: Conn| async move { conn.render(HelloTemplate { name: &quot;world&quot; }) });
}</code></pre>
<p><a href="https://docs.trillium.rs/trillium_askama/index.html">rustdocs (main)</a></p>
<h3 id="ructe"><a class="header" href="#ructe">Ructe</a></h3>
<p>Ructe is a compile-time typed template system similar to askama, but using a build script instead of macros.</p>
<ul>
<li>crate: https://crates.io/crates/trillium-ructe</li>
<li>repository: https://github.com/prabirshrestha/trillium-ructe</li>
<li>docs: https://docs.rs/trillium-ructe/latest/trillium_ructe/</li>
</ul>
<h3 id="tera"><a class="header" href="#tera">Tera</a></h3>
<p>Tera offers runtime templating. Trillium's tera integration provides an interface very similar to <code>phoenix</code> or <code>rails</code>, with the notion of <code>assigns</code> being set on the conn prior to render.</p>
<p>Given the following file in the same directory as main.rs (examples in this case),</p>
<pre><code class="language-django">Hello, {{ name }}!
</code></pre>
<pre><code class="language-rust noplaypen">use trillium::Conn;
use trillium_tera::{TeraConnExt, TeraHandler};

fn main() {
    trillium_smol::run((TeraHandler::new(&quot;**/*.html&quot;), |conn: Conn| async move {
        conn.assign(&quot;name&quot;, &quot;hi&quot;).render(&quot;examples/hello.html&quot;)
    }));
}</code></pre>
<p><a href="https://docs.trillium.rs/trillium_tera/index.html">rustdocs (main)</a></p>
<h3 id="handlebars"><a class="header" href="#handlebars">Handlebars</a></h3>
<p>Handlebars also offers runtime templating. Given the following file in <code>examples/templates/hello.hbs</code>,</p>
<pre><code class="language-handlebars">hello {{name}}!
</code></pre>
<pre><code class="language-rust noplaypen">use trillium::Conn;
use trillium_handlebars::{HandlebarsConnExt, HandlebarsHandler};

fn main() {
    env_logger::init();
    trillium_smol::run((
        HandlebarsHandler::new(&quot;./examples/templates/*.hbs&quot;),
        |conn: Conn| async move {
            conn.assign(&quot;name&quot;, &quot;world&quot;)
                .render(&quot;examples/templates/hello.hbs&quot;)
        },
    ));
}</code></pre>
<p><a href="https://docs.trillium.rs/trillium_handlebars/index.html">rustdocs (main)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="logger"><a class="header" href="#logger">Logger</a></h2>
<p><a href="https://docs.trillium.rs/trillium_logger/">rustdocs (main)</a></p>
<pre><code class="language-rust noplaypen">use trillium::{Conn, State};
use trillium_logger::{apache_combined, Logger};

#[derive(Clone, Copy)]
struct User(&amp;'static str);

impl User {
    pub fn name(&amp;self) -&gt; &amp;'static str {
        self.0
    }
}

fn user_id(conn: &amp;Conn, _color: bool) -&gt; &amp;'static str {
    conn.state::&lt;User&gt;().map(User::name).unwrap_or(&quot;-&quot;)
}

pub fn main() {
    trillium_smol::run((
        State::new(User(&quot;jacob&quot;)),
        Logger::new().with_formatter(apache_combined(&quot;-&quot;, user_id)),
        &quot;ok&quot;,
    ));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cookies"><a class="header" href="#cookies">Cookies</a></h2>
<p><a href="https://docs.trillium.rs/trillium_cookies/index.html">rustdocs (main)</a></p>
<pre><code class="language-rust noplaypen">use trillium::Conn;
use trillium_cookies::{cookie::Cookie, CookiesConnExt, CookiesHandler};

pub fn main() {
    env_logger::init();

    trillium_smol::run((CookiesHandler::new(), |conn: Conn| async move {
        if let Some(cookie_value) = conn.cookies().get(&quot;some_cookie&quot;) {
            println!(&quot;current cookie value: {}&quot;, cookie_value.value());
        }

        conn.with_cookie(
            Cookie::build(&quot;some_cookie&quot;, &quot;some-cookie-value&quot;)
                .path(&quot;/&quot;)
                .finish(),
        )
        .ok(&quot;ok!&quot;)
    }));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sessions"><a class="header" href="#sessions">Sessions</a></h2>
<p><a href="https://docs.trillium.rs/trillium_sessions/index.html">rustdocs (main)</a></p>
<p>Sessions are a common convention in web frameworks, allowing for a
safe and secure way to associate server-side data with a given http
client (browser). Trillium's session storage is built on the
<code>async-session</code> crate, which allows us to share session stores with
tide. Currently, these session stores exist:</p>
<ul>
<li>MemoryStore (reexported as trillium_sessions::MemoryStore) <sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>CookieStore (reexported as trillium_sessions::CookieStore) <sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>PostgresSessionStore and SqliteSessionStore from <a href="https://github.com/jbr/async-sqlx-session">async-sqlx-session</a></li>
<li>RedisSessionStore from <a href="https://github.com/jbr/async-redis-session">async-redis-session</a></li>
<li>MongodbSessionStore from <a href="https://github.com/http-rs/async-mongodb-session">async-mongodb-session</a></li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The memory store and cookie store should be avoided for use in
production applications. The memory store will lose all session
state on server process restart, and the cookie store makes
different security tradeoffs than the database-backed stores. If
possible, use a database.</p>
</div>
<blockquote>
<p>❗The session handler <em>must</em> be used in conjunction with the cookie
handler, and it must run <em>after</em> the cookie handler. This particular
interaction is also present in other frameworks, and is due to the
fact that regardless of which session store is used, sessions use a
secure cookie as a unique identifier.</p>
</blockquote>
<pre><code class="language-rust noplaypen">use trillium::Conn;
use trillium_cookies::CookiesHandler;
use trillium_sessions::{MemoryStore, SessionConnExt, SessionHandler};

pub fn main() {
    env_logger::init();

    trillium_smol::run((
        CookiesHandler::new(),
        SessionHandler::new(MemoryStore::new(), &quot;01234567890123456789012345678901123&quot;),
        |conn: Conn| async move {
            let count: usize = conn.session().get(&quot;count&quot;).unwrap_or_default();
            conn.with_session(&quot;count&quot;, count + 1)
                .ok(format!(&quot;count: {count}&quot;))
        },
    ));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxy"><a class="header" href="#proxy">Proxy</a></h1>
<p>Trillium includes a custom http client implementation in order to
support reverse proxying requests. There are two tls implementations
for this client.</p>
<pre><code class="language-rust noplaypen">use trillium_logger::Logger;
use trillium_rustls::RustlsConnector;
use trillium_smol::TcpConnector;

type Proxy = trillium_proxy::Proxy&lt;RustlsConnector&lt;TcpConnector&gt;&gt;;

pub fn main() {
    env_logger::init();
    trillium_smol::run((Logger::new(), Proxy::new(&quot;https://httpbin.org/&quot;)));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="static-file-serving"><a class="header" href="#static-file-serving">Static file serving</a></h2>
<p>Trillium offers two rudimentary approaches to static file serving for now. Neither of these approaches perform any cache-related header checking yet.</p>
<h3 id="from-disk"><a class="header" href="#from-disk">From disk</a></h3>
<p>This handler loads content from disk at request, and does not yet do any in-memory caching.</p>
<p><a href="https://docs.trillium.rs/trillium_static/index.html">rustdocs (main)</a></p>
<pre><code class="language-rust noplaypen">#[cfg(unix)]
pub fn main() {
    use trillium_static::{crate_relative_path, files};
    trillium_smol::run((
        trillium_logger::logger(),
        files(crate_relative_path!(&quot;examples/files&quot;)).with_index_file(&quot;index.html&quot;),
    ))
}

#[cfg(not(unix))]
pub fn main() {}</code></pre>
<h3 id="from-memory-at-compile-time"><a class="header" href="#from-memory-at-compile-time">From memory, at compile time</a></h3>
<p>This handler includes all of the static content in the compiled binary, allowing it to be shipped independently from the assets.</p>
<p><a href="https://docs.trillium.rs/trillium_static_compiled/index.html">rustdocs (main)</a></p>
<pre><code class="language-rust noplaypen">#[cfg(unix)]
pub fn main() {
    use trillium_static_compiled::static_compiled;

    trillium_smol::run((
        trillium_logger::Logger::new(),
        trillium_caching_headers::CachingHeaders::new(),
        static_compiled!(&quot;./examples/files&quot;).with_index_file(&quot;index.html&quot;),
    ));
}

#[cfg(not(unix))]
pub fn main() {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="websocket-support"><a class="header" href="#websocket-support">WebSocket support</a></h2>
<p><a href="https://docs.trillium.rs/trillium_websockets/index.html">rustdocs (main)</a></p>
<pre><code class="language-rust noplaypen">use futures_util::StreamExt;
use trillium_websockets::{websocket, Message, WebSocketConn};

async fn websocket_handler(mut conn: WebSocketConn) {
    while let Some(Ok(Message::Text(input))) = conn.next().await {
        conn.send_string(format!(&quot;received your message: {}&quot;, &amp;input))
            .await;
    }
}

pub fn main() {
    trillium_smol::run(websocket(websocket_handler));
}</code></pre>
<blockquote>
<p>🌊 WebSockets work a lot like tide's, since I recently wrote that
interface as well. One difference in trillium is that the websocket
connection also contains some aspects of the original http request,
such as request headers, the request path and method, and any state
that has been accumulated by previous handlers in a sequence.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-trillium-applications"><a class="header" href="#testing-trillium-applications">Testing trillium applications</a></h1>
<p>Trillium provides a testing crate that intends to provide both
&quot;functional/unit testing&quot; and &quot;integration testing&quot; of trillium
applications.</p>
<p><a href="https://docs.trillium.rs/trillium_testing">rustdocs (main)</a></p>
<p>Given a totally-contrived application like this:</p>
<pre><code class="language-rust noplaypen">use trillium::{conn_try, Conn, Handler, KnownHeaderName};
use trillium_logger::Logger;

async fn teapot(mut conn: Conn) -&gt; Conn {
    let request_body = conn_try!(conn.request_body_string().await, conn);
    if request_body.is_empty() {
        conn.with_status(406).with_body(&quot;unacceptable!&quot;).halt()
    } else {
        conn.with_body(format!(&quot;request body was: {request_body}&quot;))
            .with_status(418)
            .with_header(KnownHeaderName::Server, &quot;zojirushi&quot;)
    }
}

fn application() -&gt; impl Handler {
    (Logger::new(), teapot)
}

fn main() {
    trillium_smol::run(application());
}</code></pre>
<p>Here's what some simple tests would look like:</p>
<pre><code class="language-rust noplaypen">#[cfg(test)]
mod tests {
    use super::{application, teapot};
    use trillium_testing::prelude::*;

    #[test]
    fn handler_sends_correct_headers_and_is_a_teapot() {
        let application = application();
        assert_response!(
            post(&quot;/&quot;).with_request_body(&quot;hello trillium!&quot;).on(&amp;application),
            Status::ImATeapot,
            &quot;request body was: hello trillium!&quot;,
            &quot;server&quot; =&gt; &quot;zojirushi&quot;,
            &quot;content-length&quot; =&gt; &quot;33&quot;

        );
    }

    #[test]
    fn we_can_also_test_the_individual_handler() {
        assert_body!(
            post(&quot;/&quot;).with_request_body(&quot;a different body&quot;).on(&amp;teapot),
            &quot;request body was: a different body&quot;
        );
    }

    #[test]
    fn application_is_lemongrab_when_body_is_empty() {
        let application = application();
        assert_response!(
            post(&quot;/&quot;).on(&amp;application),
            Status::NotAcceptable,
            &quot;unacceptable!&quot;
        );
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns-for-library-authors"><a class="header" href="#patterns-for-library-authors">Patterns for library authors</a></h1>
<h2 id="state-1"><a class="header" href="#state-1">State</a></h2>
<p>Let's take a look at an implementation of a library that incrementally counts the number of conns that pass through it and attaches the number to each conn. It would be unsafe to store a u64 directly in the state set, because other libraries might be doing so, so we wrap it with a private newtype called ConnNumber. Since this isn't accessible outside of our library, we can be sure that our handler is the only place that sets it.  We provide a ConnExt trait in order to provide access to this data.</p>
<pre><code class="language-rust noplaypen">mod conn_counter {
    use std::sync::{
        atomic::{AtomicU64, Ordering},
        Arc,
    };
    use trillium::{async_trait, Conn, Handler};

    struct ConnNumber(u64);

    #[derive(Default)]
    pub struct ConnCounterHandler(Arc&lt;AtomicU64&gt;);

    impl ConnCounterHandler {
        pub fn new() -&gt; Self {
            Self::default()
        }
    }

    #[async_trait]
    impl Handler for ConnCounterHandler {
        async fn run(&amp;self, conn: Conn) -&gt; Conn {
            let number = self.0.fetch_add(1, Ordering::SeqCst);
            conn.with_state(ConnNumber(number))
        }
    }

    pub trait ConnCounterConnExt {
        fn conn_number(&amp;self) -&gt; u64;
    }

    impl ConnCounterConnExt for Conn {
        fn conn_number(&amp;self) -&gt; u64 {
            self.state::&lt;ConnNumber&gt;()
                .expect(&quot;conn_number must be called after the handler&quot;)
                .0
        }
    }
}</code></pre>
<p>And usage of the library looks like this:</p>
<pre><code class="language-rust noplaypen">use conn_counter::{ConnCounterConnExt, ConnCounterHandler};
use trillium::{Conn, Handler};

fn handler() -&gt; impl Handler {
    (ConnCounterHandler::new(), |conn: Conn| async move {
        let conn_number = conn.conn_number();
        conn.ok(format!(&quot;conn number was {conn_number}&quot;))
    })
}

fn main() {
    trillium_smol::run(handler());
}

#[cfg(test)]
mod test {
    use trillium_testing::prelude::*;

    #[test]
    fn test_conn_counter() {
        let handler = super::handler();
        assert_ok!(get(&quot;/&quot;).on(&amp;handler), &quot;conn number was 0&quot;);
        assert_ok!(get(&quot;/&quot;).on(&amp;handler), &quot;conn number was 1&quot;);
        assert_ok!(get(&quot;/&quot;).on(&amp;handler), &quot;conn number was 2&quot;);
        assert_ok!(get(&quot;/&quot;).on(&amp;handler), &quot;conn number was 3&quot;);
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If you're excited about the ideas here, this page will be kept up to date with ways to get involved.</p>
<ol>
<li>Build stuff <em>using</em> trillium. Open source if possible, but even if not, feedback from actual deployed applications will be given higher priority than issues that aren't driven by real use cases.</li>
<li>Build new handlers for trillium. The intent of trillium's design is that as many components as possible should be replaceable. It would make me very happy to deprecate one of the components I built in preference to a more robust alternative. All trillium-compatible crates will be linked in a section of the documentation.</li>
<li>Contribute to the documentation and tests</li>
<li>File issues for bugs</li>
</ol>
<blockquote>
<p>❗Please don't file a Pull Request, regardless of how small, without prior discussion on an Issue. All PRs without an associated issue will be immediately closed. I value your time and want to make sure that any code you write is in an aligned direction.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
